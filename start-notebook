#! /usr/bin/env python

import sys
from signal import signal, SIGINT, SIGTERM
from os.path import join as join_path
from optparse import OptionParser
from subprocess import Popen, PIPE, STDOUT
from pipes import quote

# detect when the ssh keypair isn't installed and advise the user (hint: ssh-agent sets various environment variables)
# option: script to run on login
# option: commands to run on login
# check for conflicting port forwarding in ssh config and warn
# don't overwrite config files on upload
#   optionally save dated backups or just overwrite
# can have a default number of engines in notebook cluster tab?
# take extra arguments to pass to the ipython command (--pylab=inline --no-mathjax)
# option: open the browser automatically
# view ipython configuration files on JASMIN
# set ipython configuration files on JASMIN by uploading them from their desktop
#   particularly to allow configuration of ipython-cluster to utilise the right number of nodes

ERR_EXEC = 1
# optparse returns 2 for option-parsing errors
ERR_NET = 3

defaults = {
    'local_port': 8888,
    'remote_port': 8888,
    'ipython': 'ipython',
    'verbose': False
}

desc = '''This script starts an IPython notebook server on the JASMIN virtual \
machine at the given address (HOST argument).  The web interface is forwarded \
over an SSH connection to a local port, defaulting to {0}.  Make sure your \
SSH keys are in place.'''.format(defaults['local_port'])

note = '''Before starting the notebook on JASMIN, your shell will be run as a \
login shell, which means loading, eg. ~/.bash_profile.  Bear this in mind \
when passing the --directory and --ipython options.'''

def finish (sig, process):
    """Signal handler."""
    process.send_signal(sig)

def error (msg, code, process = None):
    """Print an error message and exit."""
    print >> sys.stdout, 'error:', msg + '\r'
    if process is not None:
        finish(SIGTERM, process)
        process.wait()
    sys.exit(code)

def info (*msgs):
    print '[INFO]',
    for msg in msgs[:-1]:
        print msg,
    print msgs[-1]

def run (host, local_port, remote_port, directory, ipython, verbose):
    # construct ipython command
    ipython_cmd = (ipython, 'notebook', '--no-browser',
                   '--port={0}'.format(remote_port))
    # construct shell commands
    # 'ssh <command>' runs '$SHELL -c <command>'
    if directory is not None:
        cmds = [('cd', directory), 'echo [INFO] now in \\"`pwd`\\"']
    else:
        cmds = []
    cmds.append(('exec',) + ipython_cmd)
    # quote shell commands
    cmds = [cmd if isinstance(cmd, basestring) else \
            ' '.join(quote(arg) for arg in cmd) for cmd in cmds]
    # construct ssh command
    ssh_opts = ['-t']
    ssh_opts.append('-L{0}:localhost:{1}'.format(local_port, remote_port))
    ssh_cmd = ['ssh'] + ssh_opts + [host, '\n'.join(cmds)]
    # run command
    if verbose:
        info('running command:', '\'{0}\'\n'.format('\' \''.join(ssh_cmd)))
    process = Popen(ssh_cmd, stdout = PIPE, stderr = STDOUT)
    # set up signal handlers
    signal(SIGINT, lambda sig, frame: finish(sig, process))
    signal(SIGTERM, lambda sig, frame: finish(sig, process))
    # look through stdout for a specific printed line
    search_line = '[NotebookApp] The IPython Notebook is running at:'
    err_line = 'channel_setup_fwd_listener: cannot listen to port:'
    while True:
        s = process.stdout.readline()
        if len(s) == 0:
            # something went wrong
            break
        if s.startswith(search_line):
            if str(remote_port) + '/' not in s:
                # printed port isn't the one we wanted
                error('couldn\'t set up port forwarding: remote port ({0}) ' \
                      'is in use'.format(remote_port), ERR_NET, process)
            else:
                # replace remote with local port
                sys.stdout.write(s.replace(str(remote_port), str(local_port)))
                break
        # write line back out
        sys.stdout.write(s)
        if s.startswith(err_line):
            # ssh error
            error('couldn\'t set up port forwarding: local port ({0}) is ' \
                  'in use'.format(local_port), ERR_NET, process)
    # no way to switch output back to stdout, so we need to relay everything
    while True:
        # read one character at a time so that input is echoed immediately
        c = process.stdout.read(1)
        if len(c) == 0:
            # process has finished
            break
        sys.stdout.write(c)
        sys.stdout.flush()
    ret = process.wait()
    # handle errors indicated by return code (TODO)
    # NOTE: ssh error exit code is 255, else command's exit code
    if verbose:
        info('return code:', ret)

if __name__ == '__main__':
    # parse arguments
    op = OptionParser(usage = '%prog [OPTIONS] HOST', version = '%prog 0.1.0',
                      description = desc, epilog = note)
    op.add_option('-l', '--local-port', action = 'store', type = 'int',
                  help = 'port to run the notebook on on this machine ' \
                         '(default: %default)')
    op.add_option('-r', '--remote-port', action = 'store', type = 'int',
                  help = 'port to run the notebook on on the remote machine' \
                         '(default: %default)')
    op.add_option('-d', '--directory', action = 'store', type = 'string',
                  help = 'directory to run the notebook server in (default: ' \
                         'initial directory)')
    op.add_option('-i', '--ipython', action = 'store', type = 'string',
                  help = 'path to ipython executable (default: %default)')
    op.add_option('-v', '--verbose', action = 'store_true')
    op.set_defaults(**defaults)
    options, args = op.parse_args()
    if options.verbose:
        info('recieved options:', str(options))
        info('recieved arguments:', str(args))
    if len(args) < 1:
        op.error('expected \'host\' argument')
    elif len(args) > 1:
        op.error('got more arguments than expected')
    # run script
    ret = run(*args, **options.__dict__)