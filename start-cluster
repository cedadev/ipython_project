#! /usr/bin/env python

# TODO:
# - make valid in Python 2.5/version check
# - handle user@host-style hostnames
# - configurable ip* paths - in config, per-host: have "paths": {HOST: [...]}
# - wait for engines/notebooks on each host in turn to start before moving to next host
# - check for asking for fingerprint confirmation
# - check for asking for password
# - check for stalled engines
# - restart processes if they die?  Careful of changed connection files

from sys import exit
from time import strftime, sleep
from signal import signal, SIGINT, SIGTERM, SIGHUP
import optparse
import os
from tempfile import mkstemp
from shutil import copyfile
from subprocess import Popen, PIPE
import shlex
import socket
import json
from pipes import quote

USAGE = '%prog [OPTIONS] CONFIG_FILE'
HELP = '''
This script starts an IPython cluster across multiple machines according to the
configuration file CONFIG_FILE.  This is a JSON file containing a dict with
keys:
    controller: controller host.
    engines [optional]: a dict of engines to run.  Keys are hosts and values
                        are the numbers of engines to run.
    notebooks [optional]: a list of hosts to run notebook servers on.

In each case, a host is a dict with keys:
    host: the hostname or IP, as you would pass to SSH to connect to it,
          excluding the port (user@host is not currently supported).
    port [default = 8888]: Port to listen on for notebook connections.
    profile [default = 'default']: IPython profile to use for this process.
    options: a list of extra command-line options to pass to the notebook
             server (should not contain --port).  --no-browser is appended
             automatically if this is not running on the local machine.
    clients: a list of hosts to forward the notebook's port to.

The accepted keys depends on the type of host:
    notebooks: host, port, profile, options, clients.
    notebook clients: host, port (port is the port on the client to bind the
                      notebook server's port to).
    all others: host, profile.

Hosts may also be given as strings or lists.  Lists contain values in the same
order as keys are listed above, and possibly truncated to exclude any trailing
optional arguments.  Strings contain the same arguments separated by `:'
characters; leave sections empty for defaults, and note that this form cannot
handle arguments that are lists.  For example, the following are equivalent:
    "somehost"
    "somehost:default"
    ["somehost"]
    ["somehost", "default"]
    {"host": "somehost"}
    {"host": "somehost", "profile": "default"}

A full example, which runs the controller, notebook server and 2 engines on
`host1', 4 engines on `host2' and 4 engines locally:

{
    "controller": "host1:another_profile",
    "engines": {
        "localhost:remote_profile": 4,
        "host1": 2,
        "host2": 4
    },
    "notebooks": [
        {
            "host": "host1",
            "port": 5000,
            "options": ["--notebook-dir=~/ipython", "--pylab=inline"]
        }
    ]
}

Log files from every process this script runs are saved in the working
directory; if something doesn't work, look through these first.

Known issues:
 - Connections might hang on fingerprint confirmation, even if you've made the
   same connection before, because of the way they are made.  You might need to
   find these errors in the log files and manually perform all the connections
   once.
 - SSH connections from the local machine to any host and from any host to the
   controller's host must be passwordless.
 - Things will go wrong if your shell configuration files on any remote host
   print anything to stdout.
 - python, ipython, ipcontroller and ipengine are assumed to be on the path
   where they are used (python and ipython on every host).
 - A /lot/ of log files are created in the working directory while running.

To stop this script and all running components, send one of SIGINT (ctrl-C),
SIGTERM or SIGHUP.

The exit status in the case of an error is:
    1: invalid configuration file
    2: couldn't execute a command
    3: local I/O error'''

ERR_CONF = 1
ERR_ARGS = 2 # optparse uses this
ERR_EXEC = 3
ERR_IO = 4

DEBUG = False
WAIT_TO_KILL = 5
ENGINE = 1
CLIENT = 2
ALL = ENGINE | CLIENT
IDENT_TO_STR = {ENGINE: 'engine', CLIENT: 'client', ALL: 'all'}
PORTS = {
    'control': ((CLIENT, 'control'), (ENGINE, 'control')),
    'task': ((CLIENT, 'task'), (ENGINE, 'task')),
    'mux': ((CLIENT, 'mux'), (ENGINE, 'mux')),
    'regport': ((ALL, 'registration'),),
    'iopub': ((CLIENT, 'iopub'), (ENGINE, 'iopub')),
    'hb': ((ENGINE, 'hb_ping'), (ENGINE, 'hb_pong')),
    'notifier_port': ((CLIENT, 'notification'),)
}


def err (msg, code):
    """Print an error message and exit."""
    print 'error:', msg
    exit(code)


class PreformattedFormatter (optparse.IndentedHelpFormatter):
    """optparse text formatter for preformatted description text."""

    def format_description (self, desc):
        return desc.rstrip().lstrip('\n\r') + '\n'


class Launcher:
    """Handles starting up a cluster over SSH, including forwarding ports."""

    def __init__ (self, log_dir, preserve_logs):
        self.log_prefix = os.path.join(log_dir, strftime('%F-%T'))
        self.preserve_logs = preserve_logs
        self.hosts = {}
        self.ports = {}
        self.ipy_dirs = {}
        self.processes = []
        self.open_fs = []
        self.stopping = False
        self._stopped = True
        self._starting = False
        # add localhost so that we don't ssh to aliases for it to check their
        # IPs
        self.host('localhost')

    def launch (self, controller, engines, notebooks):
        """Start the cluster.

Takes the 'controller', 'engines' and 'notebooks' fields from the
configuration file.

"""
        if self.stopping:
            raise RuntimeError('can\'t launch while stopping')
        if not self._stopped:
            raise RuntimeError('already running: can\'t launch again')
        self._stopped = False
        self._has_con_file = {ENGINE: [], CLIENT: []}
        c_host, c_profile = self.host(controller)
        # get hosts that will connect to controller, sort by host, and disallow
        # using notebook ports for controller connections
        toctrl_hosts = {}
        hostnames = []
        self._used_ports = used_ports = {}
        for t, hosts in ((ENGINE, engines), (CLIENT, notebooks)):
            for host in hosts:
                data = self.host(host, None if t == ENGINE else 'nb')
                host = data[0]
                hostnames.append(host)
                if t == CLIENT:
                    # add notebook port to list, and check for conflicts
                    port = data[1]
                    this_used = used_ports.setdefault(host, [])
                    if port in this_used:
                        msg = 'multiple components are using port %s on %s'
                        self.bail_out(msg % (port, host), ERR_CONF)
                    this_used.append(port)
                if host != c_host:
                    toctrl_hosts[host] = toctrl_hosts.get(host, 0) | t
        hostnames = list(set(hostnames))
        # make connection host first, if present
        if c_host in hostnames:
            hostnames.insert(0, hostnames.pop(hostnames.index(c_host)))
        # notebook clients
        connecting_hosts = {}
        for notebook in notebooks:
            data = self.host(notebook, 'nb')
            n_host, n_port = data[:2]
            hosts = connecting_hosts.setdefault(n_host, {})
            for client in data[4]:
                host, port = self.host(client, 'nbclient')
                # check for conflicts
                this_used = used_ports.setdefault(host, [])
                if port in this_used:
                    msg = 'multiple components are using port %s on %s'
                    self.bail_out(msg % (port, host), ERR_CONF)
                this_used.append(port)
                if host != n_host:
                    hosts.setdefault(host, []).append((port, n_port))
        # controller: pass options for ports so we know what they are
        port_opts = self.get_ports(c_host, ALL, 'cmdline')
        cmd = ['ipcontroller', '--profile=%s' % c_profile] + port_opts
        self.run_on(c_host, cmd, 'controller')
        # get ports to forward to controller
        c_ports = self.get_ports(c_host, ALL, 'ident')
        for host, types in toctrl_hosts.iteritems():
            ports = self.get_ports(host, types, 'ident')
            toctrl_hosts[host] = [(ports[ident], c_ports[ident])
                                  for ident in ports]
        toctrl_hosts_new = connecting_hosts.setdefault(c_host, {})
        for host in toctrl_hosts:
            toctrl_hosts_new.setdefault(host, []).extend(toctrl_hosts[host])
        # forward ports
        for to_host, hosts in connecting_hosts.iteritems():
            for host, ports in hosts.iteritems():
                self.tunnel(host, to_host, ports)
        # for both engines and notebooks, some might share a filesystem with
        # the controller, so to avoid connection file clashes, start the
        # controller's first, then those on each host in turn
        for host in hostnames:
            # engines
            done = {}
            for engine, num in engines.iteritems():
                e_host, e_profile = self.host(engine)
                if e_host != host:
                    continue
                self.copy_con_file(c_host, c_profile, e_host, e_profile,
                                   ENGINE)
                for i in xrange(num):
                    n = done.get(e_profile, 0)
                    cmd = ('ipengine', '--profile=%s' % e_profile)
                    ident = '%s-engine-%s' % (e_profile, n + i)
                    self.run_on(e_host, cmd, ident)
                done[e_profile] = num
            # notebooks
            done = {}
            for notebook in notebooks:
                n_host, n_port, n_profile, opts = self.host(notebook, 'nb')[:4]
                if n_host != host:
                    continue
                self.copy_con_file(c_host, c_profile, n_host, n_profile,
                                   CLIENT)
                opts = [str(o) for o in opts]
                if n_host != 'localhost':
                    # running remotely, so running a browser is silly
                    opts.append('--no-browser')
                cmd = ['ipython', 'notebook', '--profile=%s' % n_profile,
                       '--port=%s' % n_port] + opts
                i = done.get(n_profile, 0)
                self.run_on(n_host, cmd, '%s-notebook-%s' % (n_profile, i))
                done[n_profile] = i + 1

    def wait (self):
        """Do nothing until the launcher is stopped or a subprocess dies."""
        # this should remain a reference to the process list
        ps = self.processes
        while True:
            # quit if stopped
            if self.stopping or self._stopped:
                exit(0)
            # or nothing is running
            if not ps:
                err('no processes running: stopping...', ERR_EXEC)
            # or any subprocesses have stopped
            finished = [i for i, p, w in ps if not w and p.poll() is not None]
            if finished:
                msg = 'one or more processes died or was killed:\n\t'
                self.bail_out(msg + '\n\t'.join(finished), ERR_EXEC)
            sleep(1)

    def stop (self, *args):
        """Stop all subprocesses."""
        while self._starting:
            sleep(.1)
        if self.stopping or self._stopped:
            return
        print 'stopping processes...'
        self.stopping = True
        # try TERM
        ps = self.processes
        for i, p, w in ps:
            if p.poll() is None:
                print '[stop]', i
                try:
                    p.terminate()
                except OSError:
                    # already finished
                    pass
        # wait for a while
        for j in xrange(int(WAIT_TO_KILL / .1)):
            if any(p.poll() is None for i, p, w in ps):
                sleep(.1)
            else:
                break
        # resort to KILL for still-running processes
        for i, p, w in ps:
            if p.poll() is None:
                print '[kill]', i
                try:
                    p.kill()
                except OSError:
                    # already finished
                    pass
        # close/delete log files
        delete = not self.preserve_logs
        for f in self.open_fs:
            f.close()
            if delete:
                try:
                    os.remove(f.name)
                except OSError:
                    pass
        self.stopping = False
        self._stopped = True

    def bail_out (self, msg, code):
        """Die gracefully."""
        print 'error:', msg
        self.stop()
        exit(code)

    def log_files (self, *data):
        """Return stdout/stderr log file names for a process.

Takes any number of arguments, which are just things that identify this
process.

Returns ((stdout, stderr), ident), where ident is a string identifier for this
process.

"""
        nice_data = []
        for s in data:
            nice_s = s.replace('%', '%%').replace('\0', '%')
            nice_data.append(nice_s.replace('#', '##').replace('/', '#'))
        ident = '-'.join(nice_data)
        log_file = '%s-%s-%s' % (self.log_prefix, ident, '%s')
        fs = [log_file % 'stdout', log_file % 'stderr']
        exists = os.path.exists
        while exists(fs[0] + '.log') or exists(fs[1] + '.log'):
            fs[0] += '_'
            fs[1] += '_'
            ident += '_'
        fs[0] += '.log'
        fs[1] += '.log'
        return (fs, ident)

    def run_cmd (self, cmd, log_files, ident, wait):
        """Run a command and direct its output to log files."""
        printable_cmd = ' '.join(quote(arg) for arg in cmd)
        if DEBUG:
            print printable_cmd
        # open log files
        fs = []
        for fn in log_files:
            try:
                f = open(fn, 'w')
            except IOError:
                for f in fs:
                    f.close()
                msg = 'couldn\'t open log file for writing: \'%s\''
                self.bail_out(msg % fn, ERR_IO)
            else:
                fs.append(f)
                self.open_fs.append(f)
        # run command
        if self.stopping or self._stopped:
            exit(0)
        print '[start]', ident
        self._starting = True
        try:
            p = Popen(cmd, stdin = PIPE, stdout = fs[0], stderr = fs[1])
        except OSError:
            self._starting = False
            self.bail_out('couldn\'t run command: \'%s\'' % printable_cmd,
                          ERR_EXEC)
        self.processes.append((ident, p, wait))
        self._starting = False
        if wait:
            try:
                ret = p.wait()
            except OSError:
                # can only happen if stopped (by Launcher.stop)
                exit(0)
            for f in fs:
                f.close()
            if self.stopping or self._stopped:
                exit(0)
            elif ret != 0:
                msg = 'command returned non-zero exit status (%s): \'%s\''
                self.bail_out(msg % (ret, printable_cmd), ERR_EXEC)

    def run_on (self, host, cmd, ident, wait = False):
        """Run a command on the given host over SSH.

Returns the (stdout, stderr) log files written to.

"""
        log_files, ident = self.log_files(host, ident)
        if host != 'localhost':
            cmd = ('ssh', '-tt', host, ' '.join(quote(arg) for arg in cmd))
        self.run_cmd(cmd, log_files, ident, wait)
        return log_files

    def get_output (self, host, cmd, ident):
        """Run a command and return its stdout."""
        log_files = self.run_on(host, cmd, ident, True)
        try:
            with open(log_files[0]) as f:
                out = f.read()
        except IOError:
            msg = 'couldn\'t open log file for reading: \'%s\''
            self.bail_out(msg % log_files[0], ERR_IO)
        else:
            return out

    def tunnel (self, host_on, host_to, ports):
        """Open an SSH tunnel between two hosts to forward some ports."""
        port_opts = ['-L%s:localhost:%s' % p for p in ports]
        # this will ssh to host_from first, if necessary
        self.run_on(host_on, ['ssh', host_to, '-N'] + port_opts,
                    'forward-port')

    def get_profile_dir (self, host, profile):
        """Get the directory of an IPython profile on the given host."""
        if host in self.ipy_dirs:
            # retrieve from cache
            ipy_dir = self.ipy_dirs[host]
        else:
            ipy_dir = self.get_output(host, ('ipython', 'locate'), 'locate')
            ipy_dir = ipy_dir.strip().rstrip('/')
            # cache result
            self.ipy_dirs[host] = ipy_dir
        return '%s/profile_%s' % (ipy_dir, profile)

    def copy_file (self, host_from, f_from, host_to, f_to, ident):
        """Copy a file between hosts."""
        # construct hosts
        if host_from != 'localhost':
            f_from = ':'.join((host_from, f_from))
        if host_to != 'localhost':
            f_to = ':'.join((host_to, f_to))
        if host_from == host_to == 'localhost':
            # local copy
            try:
                copyfile(f_from, f_to)
            except IOError:
                msg = 'couldn\'t copy file: \'%s\' to \'%s\''
                self.bail_out(msg % (f_from, f_to), ERR_IO)
        else:
            # copy over scp
            log_files, ident = self.log_files(ident)
            self.run_cmd(('scp', f_from, f_to), log_files, ident, True)

    def copy_con_file (self, host_from, profile_from, host_to, profile_to,
                       ident):
        """Copy a connection file between hosts.

"""
        # check if don't need to copy
        if (host_from, profile_from) == (host_to, profile_to):
            return
        # should only ever need to copy to each host once
        if (host_to, profile_to) in self._has_con_file[ident]:
            return
        self._has_con_file[ident].append((host_to, profile_to))
        s_ident = IDENT_TO_STR[ident]
        # get file paths
        f_from = self.get_profile_dir(host_from, profile_from)
        f_from = '%s/security/ipcontroller-%s.json' % (f_from, s_ident)
        f_to = self.get_profile_dir(host_to, profile_to)
        f_to = '%s/security/ipcontroller-%s.json' % (f_to, s_ident)
        # first copy to local temp file
        desc, f_temp = mkstemp()
        try:
            os.close(desc)
        except OSError:
            pass
        this_ident = '-'.join((host_from, 'getcon', profile_from, s_ident))
        self.copy_file(host_from, f_from, 'localhost', f_temp, this_ident)
        # edit with ports
        ports = self.get_ports(host_to, ident, 'confile')
        try:
            with open(f_temp) as f:
                data = json.load(f)
            if not isinstance(data, dict):
                raise ValueError()
        except (IOError, ValueError):
            self.bail_out('couldn\'t read from file: \'%s\'' % f_temp, ERR_IO)
        data.update(ports)
        # stop scary warning about not being at location
        data['location'] = '127.0.0.1'
        try:
            with open(f_temp, 'w') as f:
                json.dump(data, f, indent = 4)
        except IOError:
            self.bail_out('couldn\'t write to file: \'%s\'' % f_temp, ERR_IO)
        # copy to destination
        this_ident = '-'.join((host_to, 'setcon', profile_to, s_ident))
        self.copy_file('localhost', f_temp, host_to, f_to, this_ident)
        # clean up
        try:
            os.remove(f_temp)
        except OSError:
            pass

    def host (self, host, component = None):
        """Parse configuration host object and register aliases."""
        types = {'port': int, 'options': list, 'clients': list}
        defaults = {'port': 8888, 'profile': 'default', 'options': [],
                    'clients': []}
        if component == 'nb':
            fields = ['port', 'profile', 'options', 'clients']
        elif component == 'nbclient':
            fields = ['port']
        else:
            fields = ['profile']
        fields.insert(0, 'host')
        if isinstance(host, basestring):
            # ':'-separated fields in a string
            data = host.split(':')
        elif isinstance(host, dict):
            # field: value dict
            for k in fields:
                if k not in defaults and k not in host:
                    self.bail_out('dict-style hosts need a \'%s\' field' % k,
                                  ERR_CONF)
            data = [host.get(k, defaults.get(k)) for k in fields]
        else:
            # list of fields
            try:
                data = [v for v in host]
            except (TypeError, ValueError):
                self.bail_out('invalid host format: %s' % repr(host), ERR_CONF)
        # check types
        for i, (k, v) in enumerate(zip(fields, data)):
            if not v:
                continue
            t = types.get(k, str)
            if not isinstance(v, t):
                try:
                    v = t(v)
                except (TypeError, ValueError):
                    msg = 'invalid host format for \'%s\' field: %s'
                    self.bail_out(msg % (k, repr(v)), ERR_CONF)
            data[i] = v
        # fill in defaults
        data = data[:len(fields)]
        while len(data) < len(fields):
            data.append(None)
        for i, k in enumerate(fields):
            # check for: just appended None, or was empty in the string
            if not data[i]:
                data[i] = defaults[k]
        host = data[0]
        # get all names and add to storage
        all_hosts = self.hosts
        if host in all_hosts:
            # known host
            host = all_hosts[host]
        else:
            if host == 'localhost':
                # get hosts locally
                name = socket.gethostname()
                name, names, ips = socket.gethostbyname_ex(name)
                hosts = ['localhost', '127.0.0.1', name] + names + ips
            else:
                # get hosts remotely
                hosts = self.get_output(host, ('python', '-c', '''
import socket
name, names, ips = socket.gethostbyname_ex(socket.gethostname())
print '\\n'.join([name] + names + ips)
'''), 'get-hostnames')
                hosts = [h.strip() for h in hosts.split('\n') if h.strip()]
                hosts.append(host)
                host = hosts[0]
            for h in set(hosts):
                all_hosts[h] = host
        data[0] = host
        return data

    def _get_ports (self, host, num, used_ports, ident):
        """Get a number of suitable ports on the given host."""
        core_code = '''
ports = []
for i in xrange(%s):
    while True:
        sock = socket.socket()
        sock.bind(('', 0))
        port = sock.getsockname()[1]
        sock.close()
        if port not in ports and port not in used_ports:
            ports.append(port)
            break
'''
        if host == 'localhost':
            exec(core_code % num)
        else:
            ports = self.get_output(host, ('python', '-c', ('''
import socket
used_ports = %s
''' + core_code + '''
print '\\n'.join(str(p) for p in ports)
''') % (repr(used_ports), num)), ident)
            ports = [int(p.strip()) for p in ports.split('\n') if p.strip()]
        return ports

    def get_ports (self, host, types, format = None):
        """Get, store and return a list of suitable ports on the given host.

format is 'confile', 'cmdline', 'ident' or 'list'.

confile: {key: port} as used in connection files.
cmdline: list of controller command-line options.
ident: {ident: port}, where ident is unique across all ports and calls for
       different hosts will use the same ident for the 'same' ports.
list: just a list of port numbers.

"""
        if format == 'confile' and types not in (ENGINE, CLIENT):
            raise ValueError('\'confile\' format requires only one component')
        elif format == 'cmdline' and not (ALL & types == ALL):
            raise ValueError('\'cmdline\' format requires all components')
        ports = self.ports.setdefault(host, {})
        # get used ports and number of needed ports
        used = []
        need = 0
        for ident, defs in PORTS.iteritems():
            ps = ports.setdefault(ident, [None] * len(defs))
            for i, (t, name) in enumerate(defs):
                if types & t:
                    # want this port
                    p = ps[i]
                    if p is None:
                        need += 1
                    else:
                        used.append(p)
        # get needed ports
        if need > 0:
            used += self._used_ports.get(host, [])
            if types == ENGINE:
                ident = 'get-ports-engine'
            elif types == CLIENT:
                ident = 'get-ports-client'
            else:
                ident = 'get-ports-all'
            new = self._get_ports(host, need, used, ident)
        else:
            new = []
        # store and retrieve ports
        wanted = {}
        for ident, defs in PORTS.iteritems():
            ps = ports[ident]
            wanted_ps = []
            for i, (t, name) in enumerate(defs):
                if types & t:
                    # want this port
                    p = ps[i]
                    if p is None:
                        ps[i] = new.pop(0)
                    wanted_ps.append((name, t, ps[i]))
            if wanted_ps:
                wanted[ident] = wanted_ps
        # convert to desired format
        if format == 'confile':
            rtn = {}
            for ps in wanted.itervalues():
                for name, t, p in ps:
                    rtn[name] = p
        elif format == 'cmdline':
            rtn = []
            for ident, ps in wanted.iteritems():
                ps = ','.join(str(p) for name, t, p in ps)
                rtn.append('--HubFactory.%s=%s' % (ident, ps))
        elif format == 'ident':
            rtn = {}
            for ident, ps in wanted.iteritems():
                for name, t, p in ps:
                    rtn[name + str(t)] = p
        else: # format == 'list'
            rtn = sum(([p for name, t, p in ps] for ps in wanted.itervalues()),
                      [])
        return rtn


if __name__ == '__main__':
    op = optparse.OptionParser(usage = USAGE, description = HELP,
                               formatter = PreformattedFormatter())
    op.add_option('-d', '--log-dir', action = 'store', type = 'string',
                  default = os.getcwd(),
                  help = 'directory to use for log files (this is not ' \
                         'created)')
    op.add_option('-p', '--preserve-logs', action = 'store_true',
                  default = False,
                  help = 'whether to skip deleting log files when exiting')
    options, args = op.parse_args()
    if not args:
        op.print_help()
        exit(0)
    # load configuration file
    config = args[0]
    try:
        with open(config) as f:
            config = json.load(f)
    except IOError:
        err('configuration file not found', ERR_CONF)
    except ValueError:
        err('invalid configuration file: not valid JSON', ERR_CONF)
    if not isinstance(config, dict) or 'controller' not in config:
        err('invalid configuration file: a controller is required', ERR_CONF)
    engines = config.get('engines', {})
    if not isinstance(engines, dict):
        err('invalid configuration file: engines must be a dict', ERR_CONF)
    notebooks = config.get('notebooks', [])
    if not isinstance(notebooks, list):
        err('invalid configuration file: notebooks must be a list', ERR_CONF)
    # start launcher
    l = Launcher(options.log_dir, options.preserve_logs)
    for sig in (SIGINT, SIGTERM, SIGHUP):
        signal(sig, l.stop)
    l.launch(config['controller'], engines, notebooks)
    # wait for a subprocess to die or a signal to this process
    l.wait()