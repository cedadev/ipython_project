#! /usr/bin/env python

import sys
from signal import signal, SIGINT, SIGTERM
from os.path import join as join_path
from optparse import OptionParser
from subprocess import Popen, PIPE, STDOUT
from pipes import quote
from webbrowser import open as open_url

# option: open the browser automatically (from webbrowser import open as open_url)
# warn if no ssh-agent running
# warn (or error?) if ssh keypair isn't installed (ssh-agent sets various environment variables)
# check for conflicting port forwarding in ssh config and warn
# view/set ipython configuration files on JASMIN
#   don't overwrite config files on upload
#       option: save dated backups or just overwrite
#   check (remote) ipython environment variables for path, or take as option
#   particularly to allow configuration of ipython-cluster to utilise the right number of nodes
#       can have a default number of engines in notebook cluster tab?
# take extra arguments to pass to the ipython command (--pylab=inline --no-mathjax)
# option: script to run on login
# option: commands to run on login
# option: run notebook server locally and cluster remotely
# why are the '\r's needed?

ERR_EXEC = 1
# optparse uses 2 for option-parsing errors
ERR_NET = 3

defaults = {
    'local_port': 8888,
    'remote_port': 8888,
    'ipython': 'ipython',
    'browser': False,
    'verbose': False
}

desc = '''This script starts an IPython notebook server on the JASMIN virtual \
machine at the given address (HOST argument).  The web interface is forwarded \
over an SSH connection to a local port, defaulting to {0}.  Make sure your \
SSH keys are in place.'''.format(defaults['local_port'])

note = '''Before starting the notebook on JASMIN, your shell will be run as a \
login shell, which means loading, eg. ~/.bash_profile.  Bear this in mind \
when passing the --directory and --ipython options.'''

def finish (sig, process):
    """Signal handler."""
    process.send_signal(sig)

def error (msg, code, process = None):
    """Print an error message and exit."""
    print >> sys.stderr, '[ERROR]', msg
    if process is not None:
        finish(SIGTERM, process)
        process.wait()
    sys.exit(code)

def mk_printer (category, dest = sys.stdout, need_verbose = False):
    """Create and return a function that prints messages."""
    def printer (*msgs):
        if need_verbose and not verbose:
            return
        print >> dest, '[{0}]'.format(category.upper()),
        for msg in msgs[:-1]:
            print >> dest, msg,
        print >> dest, msgs[-1]
    return printer

info = mk_printer('info', need_verbose = True)
warn = mk_printer('warning', sys.stderr)

def run (host, local_port, remote_port, directory, ipython, browser):
    """Do everything."""
    # construct ipython command
    ipython_cmd = (ipython, 'notebook', '--no-browser',
                   '--port={0}'.format(remote_port))
    # construct shell commands
    # 'ssh <command>' runs '$SHELL -c <command>'
    if directory is not None:
        cmds = [('cd', directory), 'echo [INFO] now in \\"`pwd`\\"']
    else:
        cmds = []
    cmds.append(('exec',) + ipython_cmd)
    # quote shell commands
    cmds = [cmd if isinstance(cmd, basestring) else \
            ' '.join(quote(arg) for arg in cmd) for cmd in cmds]
    # construct ssh command
    ssh_opts = ['-t']
    ssh_opts.append('-L{0}:localhost:{1}'.format(local_port, remote_port))
    ssh_cmd = ['ssh'] + ssh_opts + [host, '\n'.join(cmds)]
    # run command
    info('running command:', '\'{0}\'\n'.format('\' \''.join(ssh_cmd)))
    process = Popen(ssh_cmd, stdout = PIPE, stderr = STDOUT)
    # set up signal handlers
    signal(SIGINT, lambda sig, frame: finish(sig, process))
    signal(SIGTERM, lambda sig, frame: finish(sig, process))
    # look through stdout for a specific printed line
    search_line = '[NotebookApp] The IPython Notebook is running at:'
    err_line = 'channel_setup_fwd_listener: cannot listen to port:'
    while True:
        s = process.stdout.readline()
        if len(s) == 0:
            # something went wrong
            break
        if s.startswith(search_line):
            if str(remote_port) + '/' not in s:
                # printed port isn't the one we wanted
                error('couldn\'t set up port forwarding: remote port ({0}) ' \
                      'is in use\r'.format(remote_port), ERR_NET, process)
            else:
                # replace remote with local port
                sys.stdout.write(s.replace(str(remote_port), str(local_port)))
                break
        # write line back out
        sys.stdout.write(s)
        if s.startswith(err_line):
            # ssh error
            error('couldn\'t set up port forwarding: local port ({0}) is ' \
                  'in use\r'.format(local_port), ERR_NET, process)
    # open in browser
    if browser:
        url = 'http://127.0.0.1:{0}'.format(local_port)
        info('opening browser to {0}\r'.format(url))
        open_url(url)
    # no way to switch output back to stdout, so we need to relay everything
    while True:
        # read one character at a time so that input is echoed immediately
        c = process.stdout.read(1)
        if len(c) == 0:
            # process has finished
            break
        sys.stdout.write(c)
        sys.stdout.flush()
    ret = process.wait()
    # handle errors indicated by return code (TODO)
    # NOTE: ssh error exit code is 255, else command's exit code
    info('return code:', ret)

if __name__ == '__main__':
    # parse arguments
    op = OptionParser(usage = '%prog [OPTIONS] HOST', version = '%prog 0.1.0',
                      description = desc, epilog = note)
    op.add_option('-l', '--local-port', action = 'store', type = 'int',
                  help = 'port to run the notebook on on this machine ' \
                         '(default: %default)')
    op.add_option('-r', '--remote-port', action = 'store', type = 'int',
                  help = 'port to run the notebook on on the remote machine' \
                         '(default: %default)')
    op.add_option('-d', '--directory', action = 'store', type = 'string',
                  help = 'directory to run the notebook server in (default: ' \
                         'initial directory)')
    op.add_option('-b', '--browser', action = 'store_true',
                  help = 'open the notebook in a web browser')
    op.add_option('-i', '--ipython', action = 'store', type = 'string',
                  help = 'path to ipython executable (default: %default)')
    op.add_option('-v', '--verbose', action = 'store_true')
    op.set_defaults(**defaults)
    options, args = op.parse_args()
    # handle arguments
    global verbose
    verbose = options.verbose
    del options.verbose
    info('recieved options:', str(options))
    info('recieved arguments:', str(args))
    if len(args) < 1:
        op.error('expected HOST argument')
    elif len(args) > 1:
        op.error('got more arguments than expected')
    # run script
    ret = run(*args, **options.__dict__)